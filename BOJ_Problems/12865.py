물건_총_개수, 최대_허용무게 = map(int, input().split())
물건들 = [(0, 0)]
for _ in range(물건_총_개수):
    무게, 가치 = map(int, input().split())
    물건들.append((무게, 가치))

최적의가방 = [[0] * (최대_허용무게+1) for _ in range(물건_총_개수+1)]

for 현재물건_idx in range(1, 물건_총_개수+1):
    for 현재_가방_허용무게 in range(1, 최대_허용무게+1):
        # 현재 물건
        현재물건 = 물건들[현재물건_idx]
        현재물건의_무게, 현재물건의_가치 = 현재물건[0], 현재물건[1]
        
        # 직전 물건
        직전물건_idx = 현재물건_idx - 1
        
        if 현재물건의_무게 > 현재_가방_허용무게:
            최적의가방[현재물건_idx][현재_가방_허용무게] = 최적의가방[직전물건_idx][현재_가방_허용무게]
        else:
            최적의가방[현재물건_idx][현재_가방_허용무게] = \
                max(
                    최적의가방[직전물건_idx][현재_가방_허용무게],
                    최적의가방[직전물건_idx][현재_가방_허용무게 - 현재물건의_무게] + 현재물건의_가치
                )
        
        
print(최적의가방[물건_총_개수][최대_허용무게])

"""
N * K 의 2차원 배열 d[n][k]를 만들어 각각의 물건을 선택할 때 마다 최대 가치를 판별해줄 수 있도록 하자.

d[n][k]는 N번째 물건 까지 살펴보았을 때, 무게가 K인 배낭의 최대 가치 이다.

 

물건을 배낭에 담을 때,

① 현재 배낭의 허용 무게보다 넣을 물건의 무게가 더 크다면 넣지 않는다.

② 그렇지 않다면, 다음 중 더 나은 가치를 선택하여 넣는다

    2-1) 현재 넣을 물건의 무게만큼 배낭에서 뺀다. 그리고 현재 물건을 넣는다.

    2-2) 현재 물건을 넣지않고 이전 배낭 그대로 가지고 간다.

 
위 과정을 식으로 나타내면 다음과 같다.

현재 담을 물건의 인덱스를 i, 현재 가방 허용 용량이 j, 현재 담을 물건의 무게를 weight, 가치 value라고 할 때,

① j < weight : d[i][j] = d[i-1][j]

② d[i][j] = max( d[i-1][ j-weight ]+value ), d[i-1][j] )

 

2-1)의 과정에서, 현재 넣을 물건의 무게만큼 배낭에서 뺀다고 한 부분에 이런 의문점이 들 수 있다.

현재 넣을 무게와 똑같은 무게의 물건이 없으면, 어떻게 빼는가? 물건이기 때문에 쪼개지 못하는데?

 

하지만, 현재 넣을 물건의 무게만큼 뺀 배낭에는,

그 무게의 배낭이 가지는 최대 가치가 저장되어 있다. 그래서 상관없다."""